# TCP 的三次握手

![img](assets/tcp.png)

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

如果只有两次握手：

1. 客户机发送第一条握手报文，由于网络阻塞没有受到服务端回应。此报文会一直在网络中。
2. TCP连接客户端有超时重传机制，如果很久没有收到服务端的确认报文（第二次握手），客户端会再次发送第一次握手报文。
3. 然后服务端向客户端发送确认报文并打开连接。
4. 客户端收到确认报文后向服务端发送数据，完成数据传输。
5. 但此时第一次受到网络阻塞的报文突然到达服务端，服务端向客户端发送确认报文并建立TCP连接。
6. 客户端收到确认报文，但客户端认为是过时的报文，便不会向客户端发送数据。
7. 服务端空等待，资源浪费

# TCP 的四次挥手

![img](assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067.jfif)

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

```
【推荐】高并发服务器建议调小 TCP协议的 time_wait超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为 处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。 正例：在linux服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：      net.ipv4.tcp_fin_timeout = 30 
```

谁先断开连接谁先进入time_wait状态，客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL（MSL报文最大存活时间）。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

# DNS域名解析过程

客户机向本地域名服务器查询域名的IP地址，如果本地域名服务器没有找到IP地址，那么本地域名服务器就会以客户端身份向其他跟域名服务器查询因此，查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。这个过程是递归的过程。

本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

# 输入一个地址发生了什么

1. 输入地址。
2. DNS解析。
3. TCP连接。
4. 发送http请求。
5. 返回http响应。
6. 浏览器解析渲染页面。
7. 断开连接。